<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fotos Impresas XV Naomi - Producciones Foro 7</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' rx='6' fill='%230a0a0f'/%3E%3Crect x='5' y='7' width='16' height='12' rx='1' fill='%23f5f0e8' stroke='%23d4af37' stroke-width='0.5' transform='rotate(-5 13 13)'/%3E%3Crect x='8' y='9' width='16' height='12' rx='1' fill='%23fff8f0' stroke='%23d4af37' stroke-width='0.5' transform='rotate(3 16 15)'/%3E%3Crect x='11' y='11' width='16' height='12' rx='1' fill='%23ffffff' stroke='%23d4af37' stroke-width='0.5'/%3E%3Crect x='13' y='13' width='12' height='8' rx='0.5' fill='%23ddd0f0'/%3E%3C/svg%3E">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, sans-serif;
            touch-action: none;
            user-select: none;
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        #title-overlay {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(212,175,55,0.6); font-size: 11px; letter-spacing: 4px;
            font-family: monospace; text-transform: uppercase;
            pointer-events: none; text-align: center;
        }
        #title-overlay .sub {
            display: block; font-size: 9px; color: rgba(255,255,255,0.3);
            letter-spacing: 2px; margin-top: 4px;
        }
        #fan-btn {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(212,175,55,0.1); border: 1px solid rgba(212,175,55,0.3);
            color: #d4af37; padding: 10px 28px; border-radius: 8px;
            font-family: monospace; font-size: 12px; letter-spacing: 3px;
            text-transform: uppercase; cursor: pointer; transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        #fan-btn:hover { background: rgba(212,175,55,0.2); border-color: rgba(212,175,55,0.5); }
        #photo-counter {
            position: fixed; bottom: 65px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.3); font-size: 10px; letter-spacing: 2px;
            font-family: monospace; pointer-events: none;
        }
        #loading-bar {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: rgba(212,175,55,0.8); font-family: monospace; font-size: 13px;
            letter-spacing: 3px; text-align: center; pointer-events: none;
            transition: opacity 0.5s;
        }
        #loading-bar .bar {
            width: 200px; height: 2px; background: rgba(255,255,255,0.1);
            margin: 12px auto 0; border-radius: 1px; overflow: hidden;
        }
        #loading-bar .fill {
            height: 100%; width: 0%; background: #d4af37;
            transition: width 0.2s;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <div id="title-overlay">
        Fotos Impresas Premium
        <span class="sub">Producciones Foro 7</span>
    </div>
    <div id="photo-counter"></div>
    <button id="fan-btn">Abanico</button>
    <div id="loading-bar">
        CARGANDO FOTOS...
        <div class="bar"><div class="fill" id="load-fill"></div></div>
        <div id="load-text" style="font-size:10px;margin-top:6px;color:rgba(255,255,255,0.3)">0 / 0</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    (function() {
        'use strict';

        // --- CONFIGURATION ---
        // Auto-detect photo count: tries loading foto1.jpg, foto2.jpg, etc.
        // until one fails to load. Supports up to 200 photos.
        const MAX_PHOTOS = 200;
        const PW = 3.0;   // photo width
        const PH = 2.0;   // photo height
        const PT = 0.02;  // photo thickness
        const STACK_GAP = 0.02; // gap between stacked photos

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a0a0f, 0.015);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('c'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.9;

        // --- BACK TEXTURE ---
        function createBackTexture() {
            const cv = document.createElement('canvas');
            cv.width = 512; cv.height = 340;
            const ctx = cv.getContext('2d');
            ctx.fillStyle = '#f8f5f0';
            ctx.fillRect(0, 0, 512, 340);
            for (let i = 0; i < 500; i++) {
                ctx.fillStyle = `rgba(${200+Math.random()*30},${195+Math.random()*30},${185+Math.random()*30},0.3)`;
                ctx.fillRect(Math.random()*512, Math.random()*340, 2, 2);
            }
            ctx.fillStyle = 'rgba(180,160,140,0.3)';
            ctx.textAlign = 'center';
            ctx.font = '14px monospace';
            ctx.fillText('PRODUCCIONES FORO 7', 256, 153);
            ctx.font = '10px monospace';
            ctx.fillText('Papel Premium \u00B7 300 DPI', 256, 187);
            return new THREE.CanvasTexture(cv);
        }
        const backTex = createBackTexture();

        // --- PLACEHOLDER TEXTURE (while loading) ---
        function createPlaceholderTexture(index) {
            const cv = document.createElement('canvas');
            cv.width = 256; cv.height = 170;
            const ctx = cv.getContext('2d');
            // Soft gradient
            const hue = (index * 37) % 360;
            ctx.fillStyle = `hsl(${hue}, 20%, 75%)`;
            ctx.fillRect(0, 0, 256, 170);
            ctx.fillStyle = `hsl(${hue}, 25%, 65%)`;
            ctx.fillRect(0, 85, 256, 85);
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.textAlign = 'center';
            ctx.font = 'bold 28px monospace';
            ctx.fillText(`${index + 1}`, 128, 95);
            return new THREE.CanvasTexture(cv);
        }

        // --- PHOTO DETECTION & LOADING ---
        const photosGroup = new THREE.Group();
        const photos = [];
        let photoCount = 0;
        let loadedCount = 0;

        function computeFanLayout(count) {
            // Determine grid columns: aim for roughly 4:3 aspect ratio of grid
            let cols = Math.ceil(Math.sqrt(count * 1.5));
            if (cols < 2) cols = 2;
            let rows = Math.ceil(count / cols);
            return { cols, rows };
        }

        function createPhotoCard(index, texture) {
            const photoGroup = new THREE.Group();

            // White card
            const cardGeo = new THREE.BoxGeometry(PW, PH, PT);
            const whiteMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const card = new THREE.Mesh(cardGeo, [
                whiteMat, whiteMat, whiteMat, whiteMat,
                whiteMat,
                new THREE.MeshPhongMaterial({ map: backTex })
            ]);
            photoGroup.add(card);

            // Photo image on front
            const borderPx = 0.08;
            const imgW = PW - borderPx * 2;
            const imgH = PH - borderPx * 2.5;
            const imgGeo = new THREE.PlaneGeometry(imgW, imgH);
            const imgMat = new THREE.MeshPhongMaterial({ map: texture });
            const imgMesh = new THREE.Mesh(imgGeo, imgMat);
            imgMesh.position.z = PT / 2 + 0.001;
            imgMesh.position.y = borderPx * 0.25;
            photoGroup.add(imgMesh);

            // Store image mesh ref for texture updates
            photoGroup.userData.imgMesh = imgMesh;

            return photoGroup;
        }

        function buildStack(count) {
            photoCount = count;
            const { cols, rows } = computeFanLayout(count);
            const gridW = PW * 1.05;
            const gridH = PH * 1.05;

            for (let i = 0; i < count; i++) {
                const placeholder = createPlaceholderTexture(i);
                const photoGroup = createPhotoCard(i, placeholder);

                const messRotZ = (Math.random() - 0.5) * 0.12;
                photoGroup.position.set(0, 0, -i * STACK_GAP);
                photoGroup.rotation.set(0, 0, messRotZ);

                // Fan position: grid layout
                const col = i % cols;
                const row = Math.floor(i / cols);
                const fanX = (col - (cols - 1) / 2) * gridW;
                const fanY = ((rows - 1) / 2 - row) * gridH;

                photoGroup.userData = {
                    ...photoGroup.userData,
                    index: i,
                    stackX: 0, stackY: 0, stackZ: -i * STACK_GAP,
                    stackRotX: 0, stackRotY: 0, stackRotZ: messRotZ,
                    fanX, fanY, fanZ: 0,
                    fanRotX: 0, fanRotY: 0, fanRotZ: 0,
                };

                photos.push(photoGroup);
                photosGroup.add(photoGroup);
            }

            scene.add(photosGroup);

            // Update counter
            document.getElementById('photo-counter').textContent =
                `${count} FOTOS \u00B7 PAPEL PREMIUM \u00B7 300 DPI`;

            // Adjust camera distance based on photo count
            const maxDim = Math.max(cols * gridW, rows * gridH);
            camFan = maxDim * 1.1 + 2;
            camBase = Math.max(4, 2 + count * 0.03);
            camDist = camBase;
            camera.position.set(camDist * 0.55, camDist * 0.55, camDist * 0.55);
            camera.lookAt(0, 0, 0);
        }

        // Load real photos progressively (replaces placeholders)
        function loadPhotosProgressive(count) {
            const loadBar = document.getElementById('loading-bar');
            const loadFill = document.getElementById('load-fill');
            const loadText = document.getElementById('load-text');
            loadText.textContent = `0 / ${count}`;

            let batch = 0;
            const BATCH_SIZE = 5; // load 5 at a time

            function loadBatch() {
                const start = batch * BATCH_SIZE;
                const end = Math.min(start + BATCH_SIZE, count);
                let pending = end - start;
                if (pending <= 0) {
                    loadBar.style.opacity = '0';
                    setTimeout(() => loadBar.style.display = 'none', 500);
                    return;
                }

                for (let i = start; i < end; i++) {
                    const img = new Image();
                    const idx = i;
                    img.onload = function() {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true;
                        // Replace placeholder texture
                        if (photos[idx]) {
                            const imgMesh = photos[idx].userData.imgMesh;
                            if (imgMesh) {
                                imgMesh.material.map = tex;
                                imgMesh.material.needsUpdate = true;
                            }
                        }
                        loadedCount++;
                        const pct = Math.round((loadedCount / count) * 100);
                        loadFill.style.width = pct + '%';
                        loadText.textContent = `${loadedCount} / ${count}`;
                        pending--;
                        if (pending <= 0) {
                            batch++;
                            // Small delay between batches to not overwhelm
                            setTimeout(loadBatch, 50);
                        }
                    };
                    img.onerror = function() {
                        loadedCount++;
                        const pct = Math.round((loadedCount / count) * 100);
                        loadFill.style.width = pct + '%';
                        loadText.textContent = `${loadedCount} / ${count}`;
                        pending--;
                        if (pending <= 0) {
                            batch++;
                            setTimeout(loadBatch, 50);
                        }
                    };
                    img.src = `fotos/foto${i + 1}.jpg`;
                }
            }
            loadBatch();
        }

        // --- AUTO-DETECT PHOTO COUNT ---
        // Probe how many foto*.jpg files exist by loading them
        function detectPhotoCount(callback) {
            let count = 0;
            let checking = 0;
            let maxFound = 0;

            // Quick probe: check in chunks to find the range fast
            function probe(n) {
                if (n > MAX_PHOTOS) {
                    // Done probing, now find exact count
                    callback(maxFound);
                    return;
                }
                checking++;
                const img = new Image();
                img.onload = function() {
                    if (n > maxFound) maxFound = n;
                    checking--;
                    probe(n + 1);
                };
                img.onerror = function() {
                    checking--;
                    // Found the gap - this is our count
                    callback(n - 1);
                };
                img.src = `fotos/foto${n}.jpg`;
            }
            probe(1);
        }

        // --- LIGHTS ---
        scene.add(new THREE.AmbientLight(0x606070, 0.5));
        const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
        mainLight.position.set(3, 5, 4);
        scene.add(mainLight);
        const warmLight = new THREE.PointLight(0xd4af37, 0.2, 20);
        warmLight.position.set(-3, 2, 3);
        scene.add(warmLight);
        const fillLight = new THREE.PointLight(0x8888cc, 0.3, 20);
        fillLight.position.set(2, -1, -3);
        scene.add(fillLight);

        // --- CAMERA ---
        let camDist = 6;
        let camBase = 6;
        let camFan = 12;

        // --- FAN ANIMATION ---
        let isFanned = false;
        let fanProgress = 0;
        let targetFanProgress = 0;

        function toggleFan() {
            isFanned = !isFanned;
            targetFanProgress = isFanned ? 1 : 0;
            document.getElementById('fan-btn').textContent = isFanned ? 'Apilar' : 'Abanico';
        }
        document.getElementById('fan-btn').addEventListener('click', toggleFan);

        // --- INTERACTION ---
        let rotX = -0.5, rotY = 0.5;
        let targetRotX = rotX, targetRotY = rotY;
        let isDragging = false;
        let dragStartX = 0, dragStartY = 0;

        function onPointerDown(x, y) { isDragging = true; dragStartX = x; dragStartY = y; }
        function onPointerMove(x, y) {
            if (!isDragging) return;
            targetRotY += (x - dragStartX) * 0.006;
            targetRotX += (y - dragStartY) * 0.006;
            targetRotX = Math.max(-1.2, Math.min(0.5, targetRotX));
            dragStartX = x; dragStartY = y;
        }
        function onPointerUp() { isDragging = false; }

        document.addEventListener('mousedown', e => onPointerDown(e.clientX, e.clientY));
        document.addEventListener('mousemove', e => onPointerMove(e.clientX, e.clientY));
        document.addEventListener('mouseup', onPointerUp);
        document.addEventListener('touchstart', e => { e.preventDefault(); onPointerDown(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        document.addEventListener('touchmove', e => { e.preventDefault(); onPointerMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        document.addEventListener('touchend', onPointerUp);

        document.addEventListener('wheel', e => {
            e.preventDefault();
            camera.position.multiplyScalar(e.deltaY > 0 ? 1.05 : 0.95);
            const d = camera.position.length();
            if (d < 2.0) camera.position.setLength(2.0);
            if (d > 60) camera.position.setLength(60);
        }, { passive: false });

        // --- ANIMATE ---
        function animate() {
            requestAnimationFrame(animate);

            rotX += (targetRotX - rotX) * 0.08;
            rotY += (targetRotY - rotY) * 0.08;
            photosGroup.rotation.x = rotX;
            photosGroup.rotation.y = rotY;

            fanProgress += (targetFanProgress - fanProgress) * 0.05;

            const targetCamDist = camBase * (1 - fanProgress) + camFan * fanProgress;
            camDist += (targetCamDist - camDist) * 0.05;
            const camDir = camera.position.clone().normalize();
            camera.position.copy(camDir.multiplyScalar(camDist));

            photos.forEach(p => {
                const d = p.userData;
                const t = fanProgress;
                p.position.x = d.stackX * (1 - t) + d.fanX * t;
                p.position.y = d.stackY * (1 - t) + d.fanY * t;
                p.position.z = d.stackZ * (1 - t) + d.fanZ * t;
                p.rotation.x = d.stackRotX * (1 - t) + d.fanRotX * t;
                p.rotation.y = d.stackRotY * (1 - t) + d.fanRotY * t;
                p.rotation.z = d.stackRotZ * (1 - t) + d.fanRotZ * t;
            });

            photosGroup.position.y = Math.sin(Date.now() * 0.001) * 0.04;
            camera.lookAt(0, 0, 0);
            renderer.render(scene, camera);
        }
        animate();

        // --- RESIZE ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- START ---
        detectPhotoCount(count => {
            if (count < 1) count = 8; // fallback
            buildStack(count);
            loadPhotosProgressive(count);
        });

    })();
    </script>
</body>
</html>
