<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fotos Impresas XV Naomi - Producciones Foro 7</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' rx='6' fill='%230a0a0f'/%3E%3Crect x='5' y='7' width='16' height='12' rx='1' fill='%23f5f0e8' stroke='%23d4af37' stroke-width='0.5' transform='rotate(-5 13 13)'/%3E%3Crect x='8' y='9' width='16' height='12' rx='1' fill='%23fff8f0' stroke='%23d4af37' stroke-width='0.5' transform='rotate(3 16 15)'/%3E%3Crect x='11' y='11' width='16' height='12' rx='1' fill='%23ffffff' stroke='%23d4af37' stroke-width='0.5'/%3E%3Crect x='13' y='13' width='12' height='8' rx='0.5' fill='%23ddd0f0'/%3E%3C/svg%3E">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, sans-serif;
            touch-action: none;
            user-select: none;
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        #title-overlay {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(212,175,55,0.6); font-size: 11px; letter-spacing: 4px;
            font-family: monospace; text-transform: uppercase;
            pointer-events: none; text-align: center;
        }
        #title-overlay .sub {
            display: block; font-size: 9px; color: rgba(255,255,255,0.3);
            letter-spacing: 2px; margin-top: 4px;
        }
        #fan-btn {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(212,175,55,0.1); border: 1px solid rgba(212,175,55,0.3);
            color: #d4af37; padding: 10px 28px; border-radius: 8px;
            font-family: monospace; font-size: 12px; letter-spacing: 3px;
            text-transform: uppercase; cursor: pointer; transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        #fan-btn:hover { background: rgba(212,175,55,0.2); border-color: rgba(212,175,55,0.5); }
        #photo-counter {
            position: fixed; bottom: 65px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.3); font-size: 10px; letter-spacing: 2px;
            font-family: monospace; pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <div id="title-overlay">
        Fotos Impresas Premium
        <span class="sub">Producciones Foro 7</span>
    </div>
    <div id="photo-counter">50 FOTOS · PAPEL PREMIUM · 300 DPI</div>
    <button id="fan-btn">Abanico</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    (function() {
        'use strict';

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a0a0f, 0.03);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('c'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.9;

        // --- PHOTO DIMENSIONS ---
        const PW = 3.0;  // photo width (landscape)
        const PH = 2.0;  // photo height
        const PT = 0.02; // photo thickness
        const PHOTO_COUNT = 8;

        // --- PHOTO FILES ---
        const photoFiles = [
            'fotos/foto1.jpg', 'fotos/foto2.jpg', 'fotos/foto3.jpg', 'fotos/foto4.jpg',
            'fotos/foto5.jpg', 'fotos/foto6.jpg', 'fotos/foto7.jpg', 'fotos/foto8.jpg'
        ];

        // Create photo texture with white border frame using real image
        function createPhotoTexture(imgSrc, index) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 340;
            const ctx = canvas.getContext('2d');
            const border = 16;

            // White photo paper
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 512, 340);

            // Number at bottom
            ctx.fillStyle = 'rgba(150,130,110,0.4)';
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            ctx.fillText((index + 1) + '/' + PHOTO_COUNT + '  Producciones Foro 7', 256, 332);

            const tex = new THREE.CanvasTexture(canvas);

            // Load real image and draw it inside the border
            const img = new Image();
            img.onload = function() {
                ctx.drawImage(img, border, border, 512 - border * 2, 340 - border * 2 - 12);
                tex.needsUpdate = true;
            };
            img.src = imgSrc;

            return tex;
        }

        function createBackTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 340;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#f8f5f0';
            ctx.fillRect(0, 0, 512, 340);

            for (let i = 0; i < 500; i++) {
                ctx.fillStyle = `rgba(${200+Math.random()*30},${195+Math.random()*30},${185+Math.random()*30},0.3)`;
                ctx.fillRect(Math.random()*512, Math.random()*340, 2, 2);
            }

            ctx.fillStyle = 'rgba(180,160,140,0.3)';
            ctx.textAlign = 'center';
            ctx.font = '14px monospace';
            ctx.fillText('PRODUCCIONES FORO 7', 256, 153);
            ctx.font = '10px monospace';
            ctx.fillText('Papel Premium \u00B7 300 DPI', 256, 187);

            return new THREE.CanvasTexture(canvas);
        }

        const backTex = createBackTexture();

        // --- CREATE PHOTOS ---
        const photosGroup = new THREE.Group();
        const photos = [];

        for (let i = 0; i < PHOTO_COUNT; i++) {
            const photoGroup = new THREE.Group();

            const frontTex = createPhotoTexture(photoFiles[i], i);

            // Photo card (thin box)
            const cardGeo = new THREE.BoxGeometry(PW, PH, PT);
            const materials = [
                new THREE.MeshPhongMaterial({ color: 0xffffff }), // right
                new THREE.MeshPhongMaterial({ color: 0xffffff }), // left
                new THREE.MeshPhongMaterial({ color: 0xffffff }), // top
                new THREE.MeshPhongMaterial({ color: 0xffffff }), // bottom
                new THREE.MeshPhongMaterial({ map: frontTex }),    // front
                new THREE.MeshPhongMaterial({ map: backTex }),     // back
            ];
            const card = new THREE.Mesh(cardGeo, materials);
            photoGroup.add(card);

            // Subtle shadow edge
            const shadowGeo = new THREE.PlaneGeometry(PW + 0.05, PH + 0.05);
            const shadowMat = new THREE.MeshPhongMaterial({
                color: 0x000000, transparent: true, opacity: 0.1, side: THREE.BackSide
            });
            const shadow = new THREE.Mesh(shadowGeo, shadowMat);
            shadow.position.z = -PT / 2 - 0.002;
            photoGroup.add(shadow);

            // Stack along Z with slight random Z-rotation per photo
            const messRotZ = (Math.random() - 0.5) * 0.12;
            photoGroup.position.x = 0;
            photoGroup.position.y = 0;
            photoGroup.position.z = -i * 0.02;
            photoGroup.rotation.x = 0;
            photoGroup.rotation.y = 0;
            photoGroup.rotation.z = messRotZ;

            // Fan: 4x2 grid covering the view plane
            const col = i % 4;
            const row = Math.floor(i / 4);
            const gridW = PW * 1.05;
            const gridH = PH * 1.05;
            const fanX = (col - 1.5) * gridW;
            const fanY = (row - 0.5) * -gridH;

            photoGroup.userData = {
                stackX: 0,
                stackY: 0,
                stackZ: -i * 0.02,
                stackRotX: 0,
                stackRotY: 0,
                stackRotZ: messRotZ,
                fanX: fanX,
                fanY: fanY,
                fanZ: 0,
                fanRotX: 0,
                fanRotY: 0,
                fanRotZ: 0,
            };

            photos.push(photoGroup);
            photosGroup.add(photoGroup);
        }

        scene.add(photosGroup);

        // --- FAN ANIMATION ---
        let isFanned = false;
        let fanProgress = 0;
        let targetFanProgress = 0;

        function toggleFan() {
            isFanned = !isFanned;
            targetFanProgress = isFanned ? 1 : 0;
            document.getElementById('fan-btn').textContent = isFanned ? 'Apilar' : 'Abanico';
        }

        document.getElementById('fan-btn').addEventListener('click', toggleFan);

        // --- LIGHTS ---
        const ambLight = new THREE.AmbientLight(0x606070, 0.5);
        scene.add(ambLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
        mainLight.position.set(3, 5, 4);
        scene.add(mainLight);

        const warmLight = new THREE.PointLight(0xd4af37, 0.2, 15);
        warmLight.position.set(-3, 2, 3);
        scene.add(warmLight);

        const fillLight = new THREE.PointLight(0x8888cc, 0.3, 15);
        fillLight.position.set(2, -1, -3);
        scene.add(fillLight);

        // --- CAMERA ---
        let camDist = 6;
        const camBase = 6;
        const camFan = 12;
        camera.position.set(camDist * 0.55, camDist * 0.55, camDist * 0.55);
        camera.lookAt(0, 0, 0);

        // --- INTERACTION ---
        let rotX = -0.5, rotY = 0.5;
        let targetRotX = rotX, targetRotY = rotY;
        let isDragging = false;
        let dragStartX = 0, dragStartY = 0;

        function onPointerDown(x, y) { isDragging = true; dragStartX = x; dragStartY = y; }
        function onPointerMove(x, y) {
            if (!isDragging) return;
            targetRotY += (x - dragStartX) * 0.006;
            targetRotX += (y - dragStartY) * 0.006;
            targetRotX = Math.max(-1.2, Math.min(0.5, targetRotX));
            dragStartX = x; dragStartY = y;
        }
        function onPointerUp() { isDragging = false; }

        document.addEventListener('mousedown', e => onPointerDown(e.clientX, e.clientY));
        document.addEventListener('mousemove', e => onPointerMove(e.clientX, e.clientY));
        document.addEventListener('mouseup', onPointerUp);
        document.addEventListener('touchstart', e => { e.preventDefault(); onPointerDown(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        document.addEventListener('touchmove', e => { e.preventDefault(); onPointerMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        document.addEventListener('touchend', onPointerUp);

        document.addEventListener('wheel', e => {
            e.preventDefault();
            camera.position.multiplyScalar(e.deltaY > 0 ? 1.05 : 0.95);
            const d = camera.position.length();
            if (d < 2.5) camera.position.setLength(2.5);
            if (d > 18) camera.position.setLength(18);
        }, { passive: false });

        // --- ANIMATE ---
        function animate() {
            requestAnimationFrame(animate);

            rotX += (targetRotX - rotX) * 0.08;
            rotY += (targetRotY - rotY) * 0.08;
            photosGroup.rotation.x = rotX;
            photosGroup.rotation.y = rotY;

            // Fan animation
            fanProgress += (targetFanProgress - fanProgress) * 0.05;

            // Smooth camera zoom for fan/stack
            const targetCamDist = camBase * (1 - fanProgress) + camFan * fanProgress;
            camDist += (targetCamDist - camDist) * 0.05;
            const camDir = camera.position.clone().normalize();
            camera.position.copy(camDir.multiplyScalar(camDist));

            photos.forEach((p, i) => {
                const d = p.userData;
                const t = fanProgress;
                p.position.x = d.stackX * (1 - t) + d.fanX * t;
                p.position.y = d.stackY * (1 - t) + d.fanY * t;
                p.position.z = d.stackZ * (1 - t) + d.fanZ * t;
                p.rotation.x = d.stackRotX * (1 - t) + d.fanRotX * t;
                p.rotation.y = d.stackRotY * (1 - t) + d.fanRotY * t;
                p.rotation.z = d.stackRotZ * (1 - t) + d.fanRotZ * t;
            });

            // Gentle float
            photosGroup.position.y = Math.sin(Date.now() * 0.001) * 0.04;

            camera.lookAt(0, 0, 0);
            renderer.render(scene, camera);
        }
        animate();

        // --- RESIZE ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    })();
    </script>
</body>
</html>
